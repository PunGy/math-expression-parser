//! LR(1) parser implementation
//!
//! This module implements the actual LR parsing algorithm using the
//! parsing tables generated by the lr_table module.

use crate::{
    ast::{BinaryOp, Expr, UnaryOp},
    error::{ParseError, ParseResult},
    grammar::{Grammar, NonTerminal, Symbol},
    lexer::Lexer,
    lr_table::{Action, LrTable},
    token::{Token, TokenType},
};
use std::fmt;

/// Stack element for the LR parser
#[derive(Debug, Clone)]
enum StackElement {
    State(usize),
    Symbol(Symbol, Option<ParseNode>),
}

/// Parse tree node (intermediate representation before AST)
#[derive(Debug, Clone)]
enum ParseNode {
    Terminal(Token),
    NonTerminal(NonTerminal, Vec<ParseNode>),
}

/// LR(1) parser for calculator expressions
pub struct Parser {
    table: LrTable,
}

impl Parser {
    /// Create a new parser
    pub fn new() -> Self {
        let grammar = Grammar::new();
        let table = LrTable::new(grammar);

        Self { table }
    }

    /// Parse an input string into an AST
    pub fn parse(&mut self, input: &str) -> ParseResult<Expr> {
        let mut lexer = Lexer::new(input);
        let tokens = lexer.tokenize()?;

        self.parse_tokens(tokens)
    }

    /// Parse a sequence of tokens into an AST
    pub fn parse_tokens(&mut self, tokens: Vec<Token>) -> ParseResult<Expr> {
        let mut stack = vec![StackElement::State(0)];
        let mut token_index = 0;

        loop {
            let current_state = self.get_current_state(&stack)?;
            let current_token = &tokens[token_index];

            match self.table.action(current_state, current_token.token_type) {
                Some(Action::Shift(next_state)) => {
                    // Shift: consume token and push new state
                    stack.push(StackElement::Symbol(
                        Symbol::Terminal(current_token.token_type),
                        Some(ParseNode::Terminal(current_token.clone())),
                    ));
                    stack.push(StackElement::State(*next_state));
                    token_index += 1;
                }

                Some(Action::Reduce(production_id)) => {
                    // Reduce: pop symbols and apply production
                    let production = &self.table.grammar.productions[*production_id];
                    let mut children = Vec::new();

                    // Pop 2 * rhs.len() elements (alternating states and symbols)
                    for _ in 0..production.rhs.len() {
                        stack.pop(); // Pop state
                        if let Some(StackElement::Symbol(_, node)) = stack.pop() {
                            if let Some(n) = node {
                                children.push(n);
                            }
                        } else {
                            return Err(ParseError::syntax_error(
                                "Invalid stack state during reduction".to_string(),
                                current_token.line,
                                current_token.column,
                            ));
                        }
                    }

                    children.reverse();

                    // Create new non-terminal node
                    let new_node = ParseNode::NonTerminal(production.lhs, children);

                    // Get goto state
                    let goto_state = self.get_current_state(&stack)?;
                    let next_state =
                        self.table.goto(goto_state, production.lhs).ok_or_else(|| {
                            ParseError::syntax_error(
                                format!(
                                    "No goto entry for state {} and {}",
                                    goto_state, production.lhs
                                ),
                                current_token.line,
                                current_token.column,
                            )
                        })?;

                    // Push new symbol and state
                    stack.push(StackElement::Symbol(
                        Symbol::NonTerminal(production.lhs),
                        Some(new_node),
                    ));
                    stack.push(StackElement::State(next_state));
                }

                Some(Action::Accept) => {
                    // Accept: parsing successful
                    // The final result should be at position 1 (after initial state 0)
                    if stack.len() >= 2 {
                        if let StackElement::Symbol(_, Some(node)) = &stack[1] {
                            return Ok(self.parse_node_to_ast(node)?);
                        }
                    }

                    return Err(ParseError::syntax_error(
                        "Invalid final stack state".to_string(),
                        current_token.line,
                        current_token.column,
                    ));
                }

                None => {
                    // Error: no valid action
                    let expected = self.expected_tokens(current_state);
                    return Err(ParseError::unexpected_token(
                        expected,
                        current_token.clone(),
                    ));
                }
            }
        }
    }

    /// Get the current state from the top of the stack
    fn get_current_state(&self, stack: &[StackElement]) -> ParseResult<usize> {
        for element in stack.iter().rev() {
            if let StackElement::State(state) = element {
                return Ok(*state);
            }
        }

        Err(ParseError::syntax_error(
            "No state found on stack".to_string(),
            0,
            0,
        ))
    }

    /// Get expected tokens for a given state
    fn expected_tokens(&self, state: usize) -> Vec<TokenType> {
        let mut expected = Vec::new();

        for terminal in &[
            TokenType::Number,
            TokenType::Plus,
            TokenType::Minus,
            TokenType::Star,
            TokenType::Slash,
            TokenType::LeftParen,
            TokenType::RightParen,
            TokenType::Eof,
        ] {
            if self.table.action(state, *terminal).is_some() {
                expected.push(*terminal);
            }
        }

        expected
    }

    /// Convert a parse node to an AST expression
    fn parse_node_to_ast(&self, node: &ParseNode) -> ParseResult<Expr> {
        match node {
            ParseNode::Terminal(token) => match token.token_type {
                TokenType::Number => Ok(Expr::Number(token.value.unwrap_or(0.0))),
                _ => Err(ParseError::syntax_error(
                    format!("Unexpected terminal in AST: {:?}", token.token_type),
                    token.line,
                    token.column,
                )),
            },

            ParseNode::NonTerminal(non_terminal, children) => {
                match non_terminal {
                    NonTerminal::Start => {
                        // S' -> E
                        if children.len() == 1 {
                            self.parse_node_to_ast(&children[0])
                        } else {
                            Err(ParseError::syntax_error(
                                "Invalid start production".to_string(),
                                0,
                                0,
                            ))
                        }
                    }

                    NonTerminal::Expr => self.parse_expr_node(children),

                    NonTerminal::Term => self.parse_term_node(children),

                    NonTerminal::Factor => self.parse_factor_node(children),
                }
            }
        }
    }

    /// Parse an Expr non-terminal node
    fn parse_expr_node(&self, children: &[ParseNode]) -> ParseResult<Expr> {
        match children.len() {
            1 => {
                // E -> T
                self.parse_node_to_ast(&children[0])
            }
            3 => {
                // E -> E + T or E -> E - T
                let left = self.parse_node_to_ast(&children[0])?;
                let right = self.parse_node_to_ast(&children[2])?;

                if let ParseNode::Terminal(op_token) = &children[1] {
                    let op = match op_token.token_type {
                        TokenType::Plus => BinaryOp::Add,
                        TokenType::Minus => BinaryOp::Subtract,
                        _ => {
                            return Err(ParseError::syntax_error(
                                "Invalid operator in expression".to_string(),
                                op_token.line,
                                op_token.column,
                            ))
                        }
                    };

                    Ok(Expr::binary(left, op, right))
                } else {
                    Err(ParseError::syntax_error(
                        "Expected operator in expression".to_string(),
                        0,
                        0,
                    ))
                }
            }
            _ => Err(ParseError::syntax_error(
                "Invalid expression production".to_string(),
                0,
                0,
            )),
        }
    }

    /// Parse a Term non-terminal node
    fn parse_term_node(&self, children: &[ParseNode]) -> ParseResult<Expr> {
        match children.len() {
            1 => {
                // T -> F
                self.parse_node_to_ast(&children[0])
            }
            3 => {
                // T -> T * F or T -> T / F
                let left = self.parse_node_to_ast(&children[0])?;
                let right = self.parse_node_to_ast(&children[2])?;

                if let ParseNode::Terminal(op_token) = &children[1] {
                    let op = match op_token.token_type {
                        TokenType::Star => BinaryOp::Multiply,
                        TokenType::Slash => BinaryOp::Divide,
                        _ => {
                            return Err(ParseError::syntax_error(
                                "Invalid operator in term".to_string(),
                                op_token.line,
                                op_token.column,
                            ))
                        }
                    };

                    Ok(Expr::binary(left, op, right))
                } else {
                    Err(ParseError::syntax_error(
                        "Expected operator in term".to_string(),
                        0,
                        0,
                    ))
                }
            }
            _ => Err(ParseError::syntax_error(
                "Invalid term production".to_string(),
                0,
                0,
            )),
        }
    }

    /// Parse a Factor non-terminal node
    fn parse_factor_node(&self, children: &[ParseNode]) -> ParseResult<Expr> {
        match children.len() {
            1 => {
                // F -> number
                self.parse_node_to_ast(&children[0])
            }
            2 => {
                // F -> - F
                if let ParseNode::Terminal(op_token) = &children[0] {
                    if op_token.token_type == TokenType::Minus {
                        let operand = self.parse_node_to_ast(&children[1])?;
                        Ok(Expr::unary(UnaryOp::Negate, operand))
                    } else {
                        Err(ParseError::syntax_error(
                            "Expected minus in unary expression".to_string(),
                            op_token.line,
                            op_token.column,
                        ))
                    }
                } else {
                    Err(ParseError::syntax_error(
                        "Expected operator in unary expression".to_string(),
                        0,
                        0,
                    ))
                }
            }
            3 => {
                // F -> ( E )
                if let (ParseNode::Terminal(left_paren), ParseNode::Terminal(right_paren)) =
                    (&children[0], &children[2])
                {
                    if left_paren.token_type == TokenType::LeftParen
                        && right_paren.token_type == TokenType::RightParen
                    {
                        self.parse_node_to_ast(&children[1])
                    } else {
                        Err(ParseError::syntax_error(
                            "Expected parentheses in grouped expression".to_string(),
                            left_paren.line,
                            left_paren.column,
                        ))
                    }
                } else {
                    Err(ParseError::syntax_error(
                        "Invalid grouped expression".to_string(),
                        0,
                        0,
                    ))
                }
            }
            _ => Err(ParseError::syntax_error(
                "Invalid factor production".to_string(),
                0,
                0,
            )),
        }
    }

    /// Print the parsing table (for debugging)
    pub fn print_table(&self) {
        self.table.print_table();
    }
}

impl Default for Parser {
    fn default() -> Self {
        Self::new()
    }
}

impl fmt::Debug for Parser {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Parser {{ {} states }}", self.table.states.len())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_simple() {
        let mut parser = Parser::new();

        let expr = parser.parse("42").unwrap();
        assert_eq!(expr.evaluate(), 42.0);

        let expr = parser.parse("2 + 3").unwrap();
        assert_eq!(expr.evaluate(), 5.0);

        let expr = parser.parse("2 * 3").unwrap();
        assert_eq!(expr.evaluate(), 6.0);
    }

    #[test]
    fn test_parse_precedence() {
        let mut parser = Parser::new();

        // Multiplication has higher precedence than addition
        let expr = parser.parse("2 + 3 * 4").unwrap();
        assert_eq!(expr.evaluate(), 14.0);

        let expr = parser.parse("2 * 3 + 4").unwrap();
        assert_eq!(expr.evaluate(), 10.0);
    }

    #[test]
    fn test_parse_parentheses() {
        let mut parser = Parser::new();

        let expr = parser.parse("(2 + 3) * 4").unwrap();
        assert_eq!(expr.evaluate(), 20.0);

        let expr = parser.parse("2 * (3 + 4)").unwrap();
        assert_eq!(expr.evaluate(), 14.0);
    }

    #[test]
    fn test_parse_unary() {
        let mut parser = Parser::new();

        let expr = parser.parse("-5").unwrap();
        assert_eq!(expr.evaluate(), -5.0);

        let expr = parser.parse("-(2 + 3)").unwrap();
        assert_eq!(expr.evaluate(), -5.0);

        let expr = parser.parse("-2 * 3").unwrap();
        assert_eq!(expr.evaluate(), -6.0);
    }

    #[test]
    fn test_parse_complex() {
        let mut parser = Parser::new();

        let expr = parser.parse("((2 + 3) * 4 - 5) / 3").unwrap();
        assert_eq!(expr.evaluate(), 5.0);

        let expr = parser.parse("-(-(-1))").unwrap();
        assert_eq!(expr.evaluate(), -1.0);
    }

    #[test]
    fn test_parse_errors() {
        let mut parser = Parser::new();

        assert!(parser.parse("2 +").is_err());
        assert!(parser.parse("2 + + 3").is_err());
        assert!(parser.parse("(2 + 3").is_err());
        assert!(parser.parse("2 @ 3").is_err());
    }
}

